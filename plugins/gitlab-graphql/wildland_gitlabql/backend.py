# Wildland Project
#
# Copyright (C) 2020 Golem Foundation
#
# Authors:
#                 Maja Kostacinska <maja@wildland.io>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""
Wildland storage backend exposing GitLab issues
"""

# pylint: disable=no-member
import stat
import itertools
from typing import List, Tuple, Iterable, Optional
from functools import partial
from pathlib import PurePosixPath
from datetime import datetime

import uuid
import click

from wildland.container import ContainerStub
from wildland.storage_backends.base import StorageBackend, Attr, File
from wildland.manifest.schema import Schema
from wildland.storage_backends.generated import GeneratedStorageMixin, FuncDirEntry, \
    FileEntry, StaticFile
from wildland.log import get_logger
from .gitlab_client import GitlabClient, CompactIssue

logger = get_logger('GitlabQLBackend')


class GitlabFileEntry(FileEntry):
    """
    A slightly modified version of the StaticFileEntry class in the .generated module.
    Provides an option to create a file entry based on the file's size; thus, the
    actual content of the file is not necessary up until the file is to be opened.
    """

    def __init__(self, issue: CompactIssue, client: GitlabClient):
        super().__init__(f'{issue.title}.md')
        self.issue = issue
        self.client = client
        self.description = self.client.get_issue_description(self.issue)

        self.attr = Attr(
            size=len(self.description),
            timestamp=int(datetime.timestamp(issue.updated_at)),
            mode=stat.S_IFREG | 0o444
        )

    def getattr(self) -> Attr:
        return self.attr

    def open(self, flags: int) -> File:
        return StaticFile((str(self.description)).encode('utf-8'), self.attr)


class GitlabQLStorageBackend(GeneratedStorageMixin, StorageBackend):
    """
    Storage backend for GitLab issues
    """

    TYPE = 'gitlab-graphql'
    SCHEMA = Schema({
        "title": "Storage manifest (GitLab)",
        "type": "object",
        "required": ["personal_token"],
        "properties": {
            "personal_token": {
                "type": "string",
                "description": "personal access token generated by GitLab"
            },
            "project_path": {
                "type": "string",
                "description": "(optional) GitLab full project path."
            },
            "category_hierarchy": {
                "type": "string",
                "description": ("(optional) Category hierarchy to be used when generating "
                                "the categories for the subcontainers"),
            }
        }
    })

    def __init__(self, **kwds):
        super().__init__(**kwds)
        self.read_only = True
        self.category_hierarchy = self.params['category_hierarchy']
        path = self.params.get('project_path')
        self.client = GitlabClient(personal_token=self.params['personal_token'],
                                   project_path=path)
        self.all_compact_issues: List[CompactIssue] = []

    def mount(self):
        """
        Forms a connection to the GitLab server
        """
        logger.debug('fetching a list of issues now:')
        path = self.params.get('project_path')
        if path:
            self.all_compact_issues = self.client.get_project_issues(path)
        else:
            self.all_compact_issues = self.client.get_compact_issues()

    def _issue_content(self, issue: CompactIssue):
        yield GitlabFileEntry(issue, self.client)

    def get_root(self):
        return FuncDirEntry('.', self._root)

    def _root(self):
        for issue in self.all_compact_issues:
            yield FuncDirEntry(self._id_issue(issue),
                               partial(self._issue_content, issue))

    @property
    def can_have_children(self) -> bool:
        return True

    def get_children(
            self,
            client=None,
            query_path: PurePosixPath = PurePosixPath('*'),
            paths_only: bool = False
    ) -> Iterable[Tuple[PurePosixPath, Optional[ContainerStub]]]:
        """
        Creates a separate container for each of the issues fetched from the server
        """
        logger.debug('creating subcontainers for the issues')
        assert self.all_compact_issues is not None
        for issue in self.all_compact_issues:
            yield self._make_issue_container(issue, paths_only)
        logger.debug('subcontainers successfully created')

    def _get_issue_categories(self, issue: CompactIssue) -> List[str]:
        """
        Generates the container categories in accordance with the category-hierarchy
        passed by the user.
        """

        permutations=[]
        paths=[]
        to_return=[]

        # this gives us an array of length at most 5 which we now need to permutate through
        to_permutate = []
        initial_split = self.category_hierarchy.split('/')
        if len(initial_split)>5:
            raise Exception('Category generation failed: wrong category hierarchy format.')

        for s in initial_split:
            to_permutate.append(s)

        # Create an array of all the possible permutations of different parts of the array, e.g.
        # - ['1', '234', '5'] -> ['125', '135', '145']
        products=list(itertools.product(*to_permutate))

        # merge the tuples into full strings in order to decode them
        for product in products:
            permutations.append(''.join(product))

        # decoding the permutations and assigning relevant categories based on those
        # this is in accordance with the explanation provided as the --help message
        # for the --category-hierarchy option
        for combination in permutations:
            categories = [(PurePosixPath('/projects') / PurePosixPath(f'{issue.project_name}'))]
            for number in combination:
                if number=='1':
                    if issue.closed:
                        for index, category in enumerate(categories):
                            categories[index] = category / PurePosixPath('closed')
                    else:
                        for index, category in enumerate(categories):
                            categories[index] = category / PurePosixPath('open')
                elif number=='2':
                    for index, category in enumerate(categories):
                        categories[index] = (category / PurePosixPath('author') /
                                            PurePosixPath(f'{issue.author}'))
                elif number=='3':
                    for index, category in enumerate(categories):
                        if issue.labels:
                            categories=self.append_labels(issue.labels, category)
                        else:
                            # if no labels, issue will be assigned the /undefined category
                            categories[index] = (category / PurePosixPath('labels') /
                                                   PurePosixPath('undefined'))
                elif number=='4':
                    for index, category in enumerate(categories):
                        if issue.milestone_title:
                            categories[index] = (category / PurePosixPath('milestones') /
                                                   PurePosixPath(f'{issue.milestone_title}'))
                        else:
                            categories[index] = (category / PurePosixPath('milestones') /
                                                   PurePosixPath('undefined'))
                elif number=='5':
                    for index, category in enumerate(categories):
                        if issue.epic_title:
                            categories[index] = (category / PurePosixPath('epics') /
                                        PurePosixPath(f'{issue.epic_title}'))
                        else:
                            categories[index] = (category / PurePosixPath('epics') /
                                                   PurePosixPath('undefined'))

            for category in categories:
                paths.append(category)

        # add the timeline tree
        date = issue.updated_at
        paths.append(PurePosixPath('/timeline') /
                     PurePosixPath('%04d' % date.year) /
                     PurePosixPath('%02d' % date.month) /
                     PurePosixPath('%02d' % date.day))

        for path in paths:
            to_return.append(str(path))

        return to_return

    @staticmethod
    def append_labels(labels: List[str], category: PurePosixPath) -> List[PurePosixPath]:
        """
        Appends all labels to a given category, creating a list
        """
        with_labels=[]

        for label in labels:
            label_category = category / PurePosixPath('labels')
            label_parts = label.split('::')
            for part in label_parts:
                with_labels.append(label_category / PurePosixPath(part))

        return with_labels

    def _id_issue(self, issue: CompactIssue) -> str:
        """
        Generates an uuid necessary in order to create the path for the subcontainers
        """
        return str(uuid.uuid3(uuid.UUID(self.backend_id), str(issue.ident)))

    def _make_issue_container(self, issue: CompactIssue, paths_only: bool = False) \
            -> Tuple[PurePosixPath, Optional[ContainerStub]]:
        """
        Creates a separate subcontainer for each of the issues fetched from the server
        """
        issue_uuid = self._id_issue(issue)
        paths = [f'/.uuid/{issue_uuid}']
        categories = self._get_issue_categories(issue)
        subcontainer_path = '/' + issue_uuid
        if not paths_only:
            return PurePosixPath(subcontainer_path), ContainerStub({
                'paths': paths,
                'title': issue.title,
                'categories': categories,
                'backends': {'storage': [{
                    'type': 'delegate',
                    'reference-container': 'wildland:@default:@parent-container:',
                    'subdirectory': subcontainer_path
                }]}
            })
        return PurePosixPath(subcontainer_path), None

    @classmethod
    def cli_options(cls):
        return [
            click.Option(
                ['--personal-token'], required=True,
                help='personal access token generated by GitLab; used for authorization purposes'),
            click.Option(
                ['--project-path'], required=False,
                help='(optional) GitLab project path'),
            click.Option(
                ['--category-hierarchy'], required=False,
                help=('the directory hierarchy to be followed when generating the issue tree; '
                      'the category options include: \n 1./open or /closed, \n'
                      '2./author/(author\'s name), \n 3./labels/(issue label) \n'
                      '4./milestone/(issue milestone) \n 5./epics/(issue epic). \n'
                      'You can customise these by passing a 5 digit combination, '
                      'such as 1/35/2 to demonstrate the following two category options: \n'
                      '-/open/labels/author, \n -/open/epics/authors'), default='1/2345')
        ]

    @classmethod
    def cli_create(cls, data):
        return {
            'personal_token': data['personal_token'],
            'project_path': data['project_path'],
            'category_hierarchy': data['category_hierarchy'],
        }
