#!/usr/bin/env bash

set -ex

. /home/user/env/bin/activate
. ci/install-inplace dropbox

function cleanup {
    time -p chronic rm -rf "$1"
    time -p chronic $WL container unmount dropbox-test-container
    time -p chronic $WL stop
}

ROOT="$HOME/wildland"
MNT_DIR_1="dropbox-mnt-1"
MNT_DIR_2="dropbox-mnt-2"
MNT_DIR_3="dropbox-mnt-3"
MNT_PATH_1="$ROOT/$MNT_DIR_1"
MNT_PATH_2="$ROOT/$MNT_DIR_2"
MNT_PATH_3="$ROOT/$MNT_DIR_3"

ACCESS_TOKEN="$1"
APP_KEY="$2"
REFRESH_TOKEN="$3"

# Wildland

WL='python3 -m coverage run -p ./wl'

$WL user create dropbox-user
$WL container create --path "/$MNT_DIR_1" --path "/$MNT_DIR_2" dropbox-test-container
if [ -n "$ACCESS_TOKEN" ]; then
    $WL storage create dropbox --container dropbox-test-container --inline --token "$ACCESS_TOKEN"
else
    $WL storage create dropbox --container dropbox-test-container --inline --app-key "$APP_KEY" --refresh-token "$REFRESH_TOKEN"
fi
$WL start --container dropbox-test-container

# Create temporary timestamped test directory

DIRNAME_DATE="$(date +%Y-%m-%d_%H:%M:%S)"
TEST_DIRPATH="$(mktemp -d -p "$MNT_PATH_1" -t gitlab-ci-dropbox-testdir_${DIRNAME_DATE}_XXXXXXXXXX)"

# Test adding 10 directories

time -p chronic mkdir -p "$TEST_DIRPATH"/dir{00..02}/subdir{00,01}

# Set cleanup handler to make sure Dropbox test directory is removed even if test doesn't pass

trap "cleanup $TEST_DIRPATH" EXIT

# List content of the root directory

time -p chronic ls -lai "$TEST_DIRPATH"

# Test non-empty files creation with echo

DEST="$TEST_DIRPATH/123.txt" time -p chronic /bin/bash -c 'echo "one two three" > "$DEST"'
DEST="$TEST_DIRPATH/456.txt" time -p chronic /bin/bash -c 'echo -n "four five six" > "$DEST"'

# Test file append

DEST="$TEST_DIRPATH/456.txt" time -p chronic /bin/bash -c 'echo -n " seven eight" >> "$DEST"'
DEST="$TEST_DIRPATH/456.txt" time -p chronic /bin/bash -c 'echo " nine ten" >> "$DEST"'

# Test file copy

time -p chronic cp "$TEST_DIRPATH/123.txt" "$TEST_DIRPATH/123_copy.txt"
time -p chronic cp "$TEST_DIRPATH/"{123,456}.txt "$TEST_DIRPATH/dir00/subdir00"

# Test file rename with no filename collision (no overwrite)

time -p chronic mv "$TEST_DIRPATH"/dir0{0,1}/subdir00/123.txt
SRC="$TEST_DIRPATH/dir01/subdir00/123.txt" time -p chronic /bin/bash -c '[[ $(cat "$SRC") == "one two three" ]]'

# Test file rename with name collision (overwrtie)

time -p chronic mv "$TEST_DIRPATH/dir00/subdir00/456.txt" "$TEST_DIRPATH/dir01/subdir00/123.txt"
SRC="$TEST_DIRPATH/dir01/subdir00/123.txt" time -p chronic /bin/bash -c '[[ $(cat "$SRC") == "four five six seven eight nine ten" ]]'

# Move directory

time -p chronic mv "$TEST_DIRPATH/dir01/subdir00" "$TEST_DIRPATH/dir02/subdir02"

# Test getattr syscall

time -p chronic stat "$TEST_DIRPATH/123.txt"
time -p chronic stat "$TEST_DIRPATH/456.txt"
time -p chronic du "$TEST_DIRPATH/123.txt"
time -p chronic du "$TEST_DIRPATH/456.txt"

# Recursive directory listing test after creation of the above files and directories

time -p chronic tree -a --inodes "$TEST_DIRPATH"

# Test readdir for both mountpoints and assert identical listing results

time -p chronic diff -rq "$MNT_PATH_1" "$MNT_PATH_2"

# Test file removal

time -p chronic rm "$TEST_DIRPATH/123_copy.txt"

# Test truncating test file

time -p chronic truncate --size 4 "$TEST_DIRPATH/456.txt"
SRC="$TEST_DIRPATH/456.txt" time -p chronic /bin/bash -c '[[ $(cat "$SRC") == "four" ]]'

# Below 2 tests check whether big file are handled correctly. Each of the below tests takes about
# 1 min to complete successfully when ran locally on Docker and over 20 minutes in GitLab pipeline.
# Running those tests may also lead to running out of space on the GitLab CI/CD server.

# Test creating 140 MiB (146800640 bytes) file and check if correct file size is reported
# (files < 150 MB are handled by different Dropbox API call than those > 150 MB)
#
# time -p chronic dd if=/dev/urandom of="$TEST_DIRPATH/140MB_file" bs=1M count=140
# sleep 10  # without sleep it reports 0 bytes for some time; issue with caching?
# FILE_SIZE=$(stat -c%s "$TEST_DIRPATH/140MB_file")
# ((FILE_SIZE==146800640))

# Test creating 300 MiB (314572800 bytes) file and check if correct file size is reported
# (files < 150 MB are handled by different Dropbox API call than those > 150 MB)
#
# time -p chronic dd if=/dev/urandom of="$TEST_DIRPATH/300MB_file" bs=1M count=300
# FILE_SIZE=$(stat -c%s "$TEST_DIRPATH/300MB_file")
# ((FILE_SIZE==314572800))

# Test storage template creation

if [ -n "$ACCESS_TOKEN" ]; then
    $WL template create dropbox --token "$ACCESS_TOKEN" mydropbox
else
    $WL template create dropbox --app-key "$APP_KEY" --refresh-token "$REFRESH_TOKEN" mydropbox
fi
$WL container create template-container --path "/$MNT_DIR_3" --template mydropbox
$WL container mount template-container

# Test simple directory/file adding

time -p chronic mkdir -p "$MNT_PATH_3"/dir1
time -p chronic mkdir -p "$MNT_PATH_3"/dir2
time -p chronic echo "test file 1" > "$MNT_PATH_3"/file1
time -p chronic echo "test file 2" > "$MNT_PATH_3"/dir1/file2

# Test listing contents of said directory

time -p chronic ls -a "$MNT_PATH_3"

# Test checking file content

SRC="$MNT_PATH_3"/file1 time -p chronic /bin/bash -c '[[ $(cat "$SRC") == "test file 1" ]]'

# Create random file locally, copy it to the Wildland mountpoint, truncate the original file by
# random number of bytes and copy it again to the Wildland mountpoint, check if the copied file
# living in the Wildland's mountpoint has correct number of bytes to make sure no garbage is in the
# end of the file (this is check against issue #607)

MIN_FILE_BYTES=$((2 ** 10))  # 1 KiB
MAX_FILE_BYTES=$((2 ** 20))  # 10 MiB
ITERATIONS=100
TMP_PATH="$(mktemp -d)"

for ((n=0;n<$ITERATIONS;n++)); do
    # create test file with random size from the range [MIN_FILE_BYTES;MAX_FILE_BYTES]
    FILE_PATH="$TMP_PATH/test"
    FILE_SIZE_BYTES=$(($MIN_FILE_BYTES + $RANDOM % ($MAX_FILE_BYTES - $MIN_FILE_BYTES + 1)))
    time -p chronic base64 /dev/urandom | head -c $FILE_SIZE_BYTES > "$FILE_PATH"

    # truncate the file locally to a random number of bytes from range [0;FILE_SIZE_BYTES]
    NEW_FILE_SIZE_BYTES=$(($RANDOM % ($FILE_SIZE_BYTES + 1)))
    time -p chronic truncate --size $NEW_FILE_SIZE_BYTES "$FILE_PATH"
    SRC="$FILE_PATH" time -p chronic /bin/bash -c '[[ $(stat --printf="%s" "$SRC") == "$NEW_FILE_SIZE_BYTES" ]]'

    # copy the truncated file back to the Wildland mountpoint and recheck if file size is correct
    time -p chronic cp "$FILE_PATH" "$MNT_PATH_3"
    SRC="$MNT_PATH_3/test" time -p chronic /bin/bash -c '[[ $(stat --printf="%s" "$SRC") == "$NEW_FILE_SIZE_BYTES" ]]'
done

time -p chronic rm -rf "$TMP_PATH"

# Unmount container

$WL c unmount template-container
