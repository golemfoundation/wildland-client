#!/usr/bin/env python3
# Wildland Project
#
# Copyright (C) 2020 Golem Foundation
#
# Authors:
#                    Marek Marczykowski-GÃ³recki <marmarek@invisiblethingslab.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

import argparse
import datetime
import itertools
import os
import random
import sqlite3
from typing import List
import lorem
import uuid

pybear_sqlite_schema = """
CREATE TABLE ZSFCHANGE ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZORDER INTEGER, ZTOKEN VARCHAR );
CREATE TABLE ZSFCHANGEITEM ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZITEMDELETED INTEGER, ZCHANGE INTEGER, ZITEMENTITY VARCHAR, ZUNIQUEIDENTIFIER VARCHAR );
CREATE TABLE ZSFEXTERNALCHANGES ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZITEMCHANGE INTEGER, ZITEMENTITY VARCHAR, ZITEMOBJECTID VARCHAR );
CREATE TABLE ZSFFOLDER ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZORDER INTEGER, ZPERMANENTLYDELETED INTEGER, ZSKIPSYNC INTEGER, ZPARENTFOLDER INTEGER, ZCREATIONDATE TIMESTAMP, ZMODIFICATIONDATE TIMESTAMP, ZTITLE VARCHAR, ZUNIQUEIDENTIFIER VARCHAR );
CREATE TABLE ZSFINTERNALCHANGES ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZITEMCHANGE INTEGER, ZCHANGETYPE VARCHAR, ZITEMOBJECTID VARCHAR );
CREATE TABLE ZSFLOCATION ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZNOTE INTEGER, ZALTITUDE FLOAT, ZCOURSE FLOAT, ZHORIZONTALACCURACY FLOAT, ZLATITUDE FLOAT, ZLONGITUDE FLOAT, ZSPEED FLOAT, ZVERTICALACCURACY FLOAT );
CREATE TABLE ZSFNOTE ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZARCHIVED INTEGER, ZENCRYPTED INTEGER, ZHASFILES INTEGER, ZHASIMAGES INTEGER, ZHASSOURCECODE INTEGER, ZLOCKED INTEGER, ZORDER INTEGER, ZPERMANENTLYDELETED INTEGER, ZPINNED INTEGER, ZSHOWNINTODAYWIDGET INTEGER, ZSKIPSYNC INTEGER, ZTODOCOMPLETED INTEGER, ZTODOINCOMPLETED INTEGER, ZTRASHED INTEGER, ZFOLDER INTEGER, ZPASSWORD INTEGER, ZSERVERDATA INTEGER, ZARCHIVEDDATE TIMESTAMP, ZCONFLICTUNIQUEIDENTIFIERDATE TIMESTAMP, ZCREATIONDATE TIMESTAMP, ZLOCKEDDATE TIMESTAMP, ZMODIFICATIONDATE TIMESTAMP, ZORDERDATE TIMESTAMP, ZPINNEDDATE TIMESTAMP, ZTRASHEDDATE TIMESTAMP, ZCONFLICTUNIQUEIDENTIFIER VARCHAR, ZENCRYPTIONUNIQUEIDENTIFIER VARCHAR, ZLASTEDITINGDEVICE VARCHAR, ZSUBTITLE VARCHAR, ZTEXT VARCHAR, ZTITLE VARCHAR, ZUNIQUEIDENTIFIER VARCHAR, ZENCRYPTEDDATA BLOB, ZVECTORCLOCK BLOB );
CREATE TABLE Z_7LINKEDNOTES ( Z_7LINKEDBYNOTES INTEGER, Z_7LINKEDNOTES INTEGER, PRIMARY KEY (Z_7LINKEDBYNOTES, Z_7LINKEDNOTES) );
CREATE TABLE Z_7TAGS ( Z_7NOTES INTEGER, Z_14TAGS INTEGER, PRIMARY KEY (Z_7NOTES, Z_14TAGS) );
CREATE TABLE ZSFNOTEFILE ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZDOWNLOADED INTEGER, ZFILESIZE INTEGER, ZINDEX INTEGER, ZPERMANENTLYDELETED INTEGER, ZSKIPSYNC INTEGER, ZUNUSED INTEGER, ZUPLOADED INTEGER, ZNOTE INTEGER, ZSERVERDATA INTEGER, ZANIMATED INTEGER, ZHEIGHT INTEGER, ZWIDTH INTEGER, ZDURATION INTEGER, ZHEIGHT1 INTEGER, ZWIDTH1 INTEGER, ZCREATIONDATE TIMESTAMP, ZMODIFICATIONDATE TIMESTAMP, ZUPLOADEDDATE TIMESTAMP, ZFILENAME VARCHAR, ZLASTEDITINGDEVICE VARCHAR, ZNORMALIZEDFILEEXTENSION VARCHAR, ZUNIQUEIDENTIFIER VARCHAR );
CREATE TABLE ZSFNOTEFILESERVERDATA ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZFILE INTEGER, Z8_FILE INTEGER, ZSYSTEMFIELDS BLOB );
CREATE TABLE ZSFNOTESERVERDATA ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZNOTE INTEGER, ZSYSTEMFIELDS BLOB );
CREATE TABLE ZSFNOTETAG ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZMODIFICATIONDATE TIMESTAMP, ZTITLE VARCHAR );
CREATE TABLE ZSFPASSWORD ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZBIOMETRY INTEGER, ZENCRYPTIONVERSION INTEGER, ZCREATIONDATE TIMESTAMP, ZCREATIONDEVICE VARCHAR, ZUNIQUEIDENTIFIER VARCHAR, ZENCRYPTEDDATA BLOB, ZHINT BLOB );
CREATE TABLE ZSFSERVERMETADATA ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZNOTEZONESUBSCRIPTIONID VARCHAR, ZNOTEZONEIDDATA BLOB, ZSERVERCHANGETOKENDATA BLOB );
CREATE TABLE ZSFSTATICNOTE ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZORDER INTEGER );
CREATE TABLE ZSFTODO ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZORDER INTEGER, ZNOTE INTEGER, ZCOMPLETIONDATE TIMESTAMP, ZCREATIONDATE TIMESTAMP, ZMODIFICATIONDATE TIMESTAMP, ZTEXT VARCHAR, ZUNIQUEIDENTIFIER VARCHAR );
CREATE TABLE ZSFURL ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZNOTE INTEGER, ZCREATIONDATE TIMESTAMP, ZMODIFICATIONDATE TIMESTAMP, ZOGDESCRIPTION VARCHAR, ZOGIMAGE VARCHAR, ZOGTITLE VARCHAR, ZOGTYPE VARCHAR, ZOGURL VARCHAR, ZOGVIDEO VARCHAR, ZTITLE VARCHAR, ZUNIQUEIDENTIFIER VARCHAR, ZURL VARCHAR );
CREATE INDEX ZSFCHANGEITEM_ZCHANGE_INDEX ON ZSFCHANGEITEM (ZCHANGE);
CREATE INDEX ZSFFOLDER_ZPARENTFOLDER_INDEX ON ZSFFOLDER (ZPARENTFOLDER);
CREATE INDEX ZSFLOCATION_ZNOTE_INDEX ON ZSFLOCATION (ZNOTE);
CREATE INDEX ZSFNOTE_ZFOLDER_INDEX ON ZSFNOTE (ZFOLDER);
CREATE INDEX ZSFNOTE_ZPASSWORD_INDEX ON ZSFNOTE (ZPASSWORD);
CREATE INDEX ZSFNOTE_ZSERVERDATA_INDEX ON ZSFNOTE (ZSERVERDATA);
CREATE INDEX Z_7LINKEDNOTES_Z_7LINKEDNOTES_INDEX ON Z_7LINKEDNOTES (Z_7LINKEDNOTES, Z_7LINKEDBYNOTES);
CREATE INDEX Z_7TAGS_Z_14TAGS_INDEX ON Z_7TAGS (Z_14TAGS, Z_7NOTES);
CREATE INDEX ZSFNOTEFILE_ZNOTE_INDEX ON ZSFNOTEFILE (ZNOTE);
CREATE INDEX ZSFNOTEFILE_ZSERVERDATA_INDEX ON ZSFNOTEFILE (ZSERVERDATA);
CREATE INDEX ZSFNOTEFILE_Z_ENT_INDEX ON ZSFNOTEFILE (Z_ENT);
CREATE INDEX ZSFNOTEFILESERVERDATA_ZFILE_INDEX ON ZSFNOTEFILESERVERDATA (ZFILE);
CREATE INDEX ZSFNOTESERVERDATA_ZNOTE_INDEX ON ZSFNOTESERVERDATA (ZNOTE);
CREATE INDEX ZSFTODO_ZNOTE_INDEX ON ZSFTODO (ZNOTE);
CREATE INDEX ZSFURL_ZNOTE_INDEX ON ZSFURL (ZNOTE);
CREATE TABLE Z_PRIMARYKEY (Z_ENT INTEGER PRIMARY KEY, Z_NAME VARCHAR, Z_SUPER INTEGER, Z_MAX INTEGER);
CREATE TABLE Z_METADATA (Z_VERSION INTEGER PRIMARY KEY, Z_UUID VARCHAR(255), Z_PLIST BLOB);
CREATE TABLE Z_MODELCACHE (Z_CONTENT BLOB);
"""


def datetime_to_timestamp(s: datetime.datetime):
    """
    Convert a Core Data timestamp to a datetime. They're all a float of seconds since 1 Jan 2001. We calculate
    the seconds in offset.
    """
    if not s:
        return 0

    OFFSET = (datetime.datetime(2001, 1, 1, 0, 0, 0) - datetime.datetime.fromtimestamp(0)).total_seconds()
    return s.timestamp() - OFFSET

class BearGenerator:
    def __init__(self, path):
        self.path = path
        self._db = sqlite3.connect(self.path)
        self._db.row_factory = sqlite3.Row

        self.timestamp_range = (datetime.datetime.now() - datetime.timedelta(days=365),
                                datetime.datetime.now())
        self.archived_p = 0.05
        self.trashed_p = 0.03
        self.deleted_p = 0.01
        self.pinned_p = 0.1

    def create_database(self):
        self._db.executescript(pybear_sqlite_schema)

    def create_tag(self, tag):
        stmt = "INSERT INTO ZSFNOTETAG(ZTITLE) VALUES (?)"
        self._db.execute(stmt, [tag])

    def random_timestamp(self):
        date_delta = (self.timestamp_range[1] - self.timestamp_range[0]).total_seconds()
        return self.timestamp_range[0] + datetime.timedelta(seconds=random.random() * date_delta)

    def generate_note(self):

        note_uuid = uuid.uuid4()
        created = self.random_timestamp()
        modified = self.random_timestamp()
        archived = None
        trashed = None
        deleted = None
        pinned = None
        if random.random() <= self.archived_p:
            archived = self.random_timestamp()
        if random.random() <= self.trashed_p:
            trashed = self.random_timestamp()
        if random.random() <= self.deleted_p:
            deleted = self.random_timestamp()
        if random.random() <= self.pinned_p:
            pinned = self.random_timestamp()

        title = lorem.get_sentence(count=1, comma=(0, 2), word_range=(4, 8))
        text = lorem.get_paragraph(count=random.randint(1, 10), comma=(0, 2), word_range=(4, 8), sentence_range=(5, 10), sep=os.linesep)

        stmt = "INSERT INTO ZSFNOTE (ZUNIQUEIDENTIFIER, ZCREATIONDATE, ZMODIFICATIONDATE, " \
               "ZARCHIVEDDATE, ZTRASHEDDATE, ZPERMANENTLYDELETED, ZPINNED, ZTITLE, ZTEXT) " \
               "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
        self._db.execute(stmt, [
            str(note_uuid),
            datetime_to_timestamp(created),
            datetime_to_timestamp(modified),
            datetime_to_timestamp(archived),
            datetime_to_timestamp(trashed),
            datetime_to_timestamp(deleted),
            datetime_to_timestamp(pinned),
            title,
            text
        ])

    def generate_notes(self, notes_count: int):
        for _ in range(notes_count):
            self.generate_note()

    def generate_tags(self, tags_count: List[int], prefix=''):
        """

        :param tags_count: number of tags at each level
        :param prefix: tag prefix
        :return:
        """
        if prefix:
            self.create_tag(prefix)
        if not tags_count:
            return
        tags = lorem.word(tags_count[0])
        for tag in itertools.islice(tags, tags_count[0]):
            if prefix:
                new_prefix = prefix + '/' + tag
            else:
                new_prefix = tag
            self.generate_tags(tags_count[1:], prefix=new_prefix)

    def list_notes(self):
        cursor = self._db.cursor()
        cursor.execute("SELECT Z_PK FROM ZSFNOTE")

        for note in cursor.fetchall():
            yield note['Z_PK']

    def list_tags(self):
        cursor = self._db.cursor()
        cursor.execute("SELECT Z_PK, ZTITLE FROM ZSFNOTETAG")

        tags = {}
        for tag in cursor.fetchall():
            tags[tag['ZTITLE']] = tag['Z_PK']

        return tags

    def assign_tags(self, min_tags, max_tags):
        all_tags = self.list_tags()
        all_tags_list = list(all_tags)

        tag_mappings = []
        for note in self.list_notes():
            tags_count = random.randint(min_tags, max_tags)
            tags = random.sample(all_tags_list, tags_count)
            for tag in tags:
                tag_mappings.append((note, all_tags[tag]))
                # and parent tags:
                while tag.count('/'):
                    tag = tag.rsplit('/', 1)[0]
                    tag_id = all_tags[tag]
                    tag_mappings.append((note, tag_id))

        self._db.executemany("INSERT INTO Z_7TAGS(Z_7NOTES, Z_14TAGS) VALUES (?, ?)", set(tag_mappings))

    def close_database(self):
        self._db.commit()
        self._db.close()

    def generate_all(self, notes_count, max_tags):
        self.create_database()
        tags_count = [10, 40, 40, 4]
        self.generate_tags(tags_count)
        self.generate_notes(notes_count)
        self.assign_tags(3, max_tags)
        self.close_database()


parser = argparse.ArgumentParser()
parser.add_argument('--notes-count', default=4000, type=int, help="How many notes to generate (%(default)s)")
parser.add_argument('--max-tags', default=10, type=int, help="Max tags for each note (%(default)s)")
parser.add_argument('database', help="Bear SQLite database path to be created")

if __name__ == '__main__':
    args = parser.parse_args()
    generator = BearGenerator(args.database)
    generator.generate_all(args.notes_count, args.max_tags)
